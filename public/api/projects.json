{
  "projects": [
    {
      "image": "dashboard_1",
      "imageSecondary": "dashboard_1",
      "imageLogo": "",
      "name": "dashboard",
      "title": "Home Lab Dashboard",
      "tags": [],
      "description": "Homelab Dashboard is a customizable web-based dashboard designed for managing and monitoring your homelab services. It provides a clean and organized interface to access various services, with support for status icons and custom icons (SVGs, dashboard icons from Homarr Labs, URLs, and Font Awesome icons). The dashboard is highly configurable, allowing you to customise it to your specific needs.",
      "sections": [
        {
          "text": "THe dashbopard is configurable using a JSON file, which allows you to define the links, color scheme, and layout of the dashboard. For the links you can specify the name, route, icon, and whether to display a service status icon for each link. The links can be seperated into sections, which can be used to create a more organized layout with their own title.",
          "image": "dashboard_2",
          "images": []
        },
        {
          "text": "",
          "image": "",
          "images": [
            "dashboard_1"
          ]
        }
      ],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/dashboard"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/simple-dashboard-go"
        }
      ]
    },
    {
      "image": "bep",
      "imageSecondary": "bep",
      "imageLogo": "",
      "name": "bep",
      "title": "Bachlor End Project - Soccer Robot Reinforcement Learning Ball Interception",
      "tags": [
        "current"
      ],
      "description": "Robot soccer presents unique challenges for adaptive behavior in dynamic environments, with Tech United developing innovative robots called TURTLEs to address these complexities. This study explores the use of reinforcement learning (RL) as an alternative to traditional methods, aiming to enhance ball interception efficiency by enabling robots to learn optimal strategies through interaction and training. The project focuses on developing a simulation environment in Unreal Engine 5.5 to train RL agents for ball interception tasks.",
      "sections": [
        {
          "text": "Reinforcement learning (RL) is a powerful machine learning technique where an agent learns to make optimal decisions by interacting with its environment, receiving feedback through rewards, and improving over time through trial and error. In Unreal Engine 5.5, RL can be done using the Learning Agents plugin, which enables training of AI agents. The plugin provides a bridge between the Unreal Engine and Python, allowing for the use of popular RL libraries like TensorFlow and PyTorch.",
          "image": "bep_1",
          "images": []
        },
        {
          "text": "The analysis highlights that reinforcement learning successfully generates ball interception trajectories, achieving high accuracy across diverse conditions, as demonstrated by Policy 4's strong performance. However, challenges remain in scenarios with high ball velocities, indicating limitations in policy adaptability under dynamic and complex conditions. These findings suggest that further refinement of reward functions and training processes could enhance the effectiveness and robustness of reinforcement learning-based interception systems.",
          "image": "bep_2",
          "images": []
        },
        {
          "text": "",
          "image": "",
          "images": [
            "bep_3",
            "bep_4",
            "bep_5",
            "bep_6"
          ]
        }
      ],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/bep"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/soccer-robot-rl-ball-interception"
        },
        {
          "name": "Final Report",
          "route": "https://github.com/tychobrouwer/soccer-robot-rl-ball-interception/blob/main/1753320-ball-interception-ue-soccer-robots-corrected.pdf"
        }
      ]
    },
    {
      "image": "mail_app_1",
      "imageSecondary": "mail_app_1",
      "imageLogo": "",
      "name": "mail_app",
      "title": "Mail Client App",
      "tags": [
        "current"
      ],
      "description": "A mail client for desktop made using flutter. The goal of this project is to make a client which simply does your mail, with the ability to customize the client by disabling features you do not need. In the current state the client can read rendered HTML emails from one or multiple IMAP servers.",
      "sections": [
        {
          "text": "The backend is written in Rust and exposes various url endpoints to communicate with the frontend. It stores a local cache of the emails in a sqlite database. It uses the imap crate to connect to the email servers and update the local database. The frontend is written in Flutter and uses the \"flutter_widget_from_html_core\" package to convert the HTML emails to Flutter widgets.",
          "image": "",
          "images": []
        },
        {
          "text": "",
          "image": "",
          "images": [
            "mail_app_2"
          ]
        },
        {
          "text": "",
          "image": "",
          "images": [
            "mail_app_3"
          ]
        },
        {
          "text": "It is the goal to create a client which can be easily customized by the user via a configuration file or via the settings menu. All colors should be customizable and derived from a few base colors. Icon sizes and pannel padding should also be customizable.",
          "image": "",
          "images": []
        },
        {
          "text": "",
          "image": "",
          "images": [
            "mail_app_4"
          ]
        }
      ],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/mail_app"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/mail-app-flutter"
        }
      ]
    },
    {
      "image": "weclean_app",
      "imageSecondary": "weclean_app",
      "imageLogo": "",
      "name": "weclean_app",
      "title": "WeClean Kotlin App",
      "tags": [
        "current"
      ],
      "description": "This app was developed for the course 4IS70 DBL App Development. The goal of the course was to develop an app for Android using Java or Kotlin. The app should incorporate a few requirements, the app should have multiple user roles, should use one or multiple hardware features of the device, shoould have an elaborate user interface, and connect to a server.",
      "sections": [
        {
          "text": "The WeClean app aims to address the issue of common littering locations and to promote sustainability by mapping littering locations and helping to predict trash build-ups. The user groups involved are residents or people passing by, who can take a photo with location, tags, and description of a littering location, which are uploaded to a server and processed. City councils, government, or volunteer organisations will be able to use the app to identify “hotspots” and resolve issues in specific locations.",
          "image": "",
          "images": []
        },
        {
          "text": "",
          "image": "",
          "images": [
            "weclean_app_1",
            "weclean_app_2",
            "weclean_app_3",
            "weclean_app_4",
            "weclean_app_5",
            "weclean_app_6",
            "weclean_app_7"
          ]
        }
      ],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/weclean_app"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/2IS70-DBL-App-Development"
        }
      ]
    },
    {
      "image": "home_server",
      "imageSecondary": "home_server",
      "imageLogo": "",
      "name": "home_server",
      "title": "Home Server",
      "tags": [
        "current"
      ],
      "description": "Since 2020 I am using an old desktop computer as a home server running Proxmox VE, which is a Debian based virtualization platform. The server is used to host a variety of services like Pi-Hole, Wireguard, SAMBA, Passbolt, Authelia, and various media services. It is all managed by a collection of Ansible scripts which allow for easy deployment and maintenance of the server.",
      "sections": [
        {
          "text": "This project is highly inspired by the homelab community on Youtube and Reddit, watching videos from Jeff Geerling, ServeTheHome, and Level1Techs. It started on basic hardware running Pi-Hole and Wireguard instances together with a SAMBA file server to sync files across my devices. The server has since been upgraded to a more powerful hardware and now runs a variety of services.",
          "image": "home_server_2",
          "images": []
        },
        {
          "text": "The project has taught me a lot about Linux, Ansible, networking, and server management. It introduced me to the Linux platform and made me confortable using the command line which I now use daily. For the future I plan to expand the server with more services and learn more about networking by adding opnsense to the list of running services.",
          "image": "home_server_3",
          "images": []
        }
      ],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/home_server"
        },
        {
          "name": "GitHub Playbooks Repo",
          "route": "https://github.com/tychobrouwer/ansible-playbooks"
        },
        {
          "name": "Github Roles Repos",
          "route": "https://github.com/tychobrouwer?tab=repositories&q=ansible-"
        }
      ]
    },
    {
      "image": "esp32_remote_car",
      "imageSecondary": "esp32_remote_car",
      "imageLogo": "",
      "name": "esp32_remote_car",
      "title": "ESP32 Remote Car",
      "tags": [
        "current"
      ],
      "description": "This project is about learning to work with microcontrollers, electrical components, and writing the code for them. The robot is controlled by an ESP32 microcontroller, and uses two MX1508 DC-motor drivers to drive the four 5V cheap motors. The speed of the wheels is tracked using four light slot sensors. The robot can be controlled using a webserver hosted on the ESP's IP-address. The webinterface communicates back to the microcontroller using a websocket connection.",
      "sections": [
        {
          "text": "The car has four 3-6 volt DC motors with a peak current draw of about 200mA. A 100nF capacitor is soldered to the terminals of each motor to reduce the noise they produce. The motors are controlled using two MX1508 DC-motor drivers. The drivers are controlled using PWM signals from the ESP32, these are generated using the MCPWM peripheral API of the esp32.",
          "image": "esp32_remote_car_4",
          "images": []
        },
        {
          "text": "The speed of the motors is tracked using four light slot sensors. The ESP32 detects the slot sensors passing to calculate the speed of the motor using the PCNT peripheral API of the esp32.",
          "image": "esp32_remote_car_6",
          "images": []
        },
        {
          "text": "I observed that one motor underperformed severly. This caused the robot to not drive straight. To compensate for this a correction factor was added to the pwm speed send to the motors based on the speed of the worst performing motor. A curve was fitted to the speed of the motors to predict the speed of the motors at different pwm values. It can also be observed that the motors have a clear minimum pwm value at which they start to move, this value mainly depended on the pwm frequency used.",
          "image": "esp32_remote_car_7",
          "images": []
        }
      ],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/esp32_remote_car"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/esp32-remote-car"
        }
      ]
    },
    {
      "image": "ac_controller_1",
      "imageSecondary": "ac_controller_1",
      "imageLogo": "",
      "name": "ac_controller",
      "title": "Universal AC Controller",
      "description": "This is a course Detailing, Realization and RPC Testing and part of the USE (User, Society, and Enterprise) learning trajectory of my study. It aims to let students experience that the design of a product needs constant interaction with the proposed use. This means going through an product design cycle with real customer/user involvement. And learning how to define and study a potential market, how to involve user demands into a technical design and how to evaluate the design in a user context.",
      "sections": [
        {
          "text": "During the project a concept design was first made after which a more complete prototype was manufactured. The product aims to allow an IR controlled air conditioner to become a smart air conditioner. The user can control their AC unit remotely using an app. The server can also relay weather information to the local device for smart temperature control by the air conditioner.",
          "image": "ac_controller_3",
          "images": []
        },
        {
          "text": "Tge device is controlled by an ESP32 microcontroller is powered either from a USB power supply or a 5V battery. It has an IR transmitter and receiver to control the AC unit by imitating the original remote. It is connected to the internet using WiFi and communicates with the server using a websocket connection. Communication between the webapp and the server is done using a REST API.",
          "image": "ac_controller_2",
          "images": []
        }
      ],
      "tags": [],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/ac_controller"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/ac-controller-api-socket-python"
        }
      ]
    },
    {
      "image": "food_alarm",
      "imageSecondary": "food_alarm_2",
      "imageLogo": "food_alarm_logo",
      "name": "food_alarm",
      "title": "Food Alarm App",
      "description": "An mobile app made for the course Engineering Design, using React Native and Expo Go. The app's goal is to decrease food waste, it attempts to achieve this by allowing the user to track the food which is in the users house. It also provides a grocery store list and recipe database linked to the food stored in the inventory.",
      "sections": [
        {
          "text": "The mobile app is written in React Native using Expo Go. React Native is an open-source framework for JavaScript. It combines React, with app development for iOS and Android. Expo is an open-source platform for making mobile apps and it removes the necessity for an iOS and Android developer account for testing the app. Expo achieves this by hosting the app on the Expo Go mobile app. The back-end server for the app, which will be used as an authorization and database server, is made using Express.js.",
          "image": "",
          "images": []
        }
      ],
      "tags": [],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/food_alarm"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/food-app-react-native"
        }
      ]
    },
    {
      "image": "pokemon_like_game",
      "imageSecondary": "pokemon_like_game_2",
      "imageLogo": "",
      "name": "pokemon_like_game",
      "title": "Pokémon Inspired Game",
      "description": "A Pokémon inspired game written using Electron, TypeScript, and SCSS, more specifically the Pokémon Ruby version. The game is drawn onto an HTML canvas using request animation frame to invoke the repaint. The game has basic fighting mechanics following the original from Pokémon Ruby.",
      "sections": [],
      "tags": [
        "old"
      ],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/pokemon_like_game"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/pokemon-game-electron"
        }
      ]
    },
    {
      "image": "snake_game",
      "imageSecondary": "snake_game",
      "imageLogo": "",
      "name": "snake_game",
      "title": "Snake Game",
      "description": "A snake game made using Electron, TypeScript, and SCSS. The game counts the current score and saves the high score. The player can also adjust the game speed and board size. ",
      "sections": [],
      "tags": [
        "old"
      ],
      "links": [
        {
          "name": "Read More",
          "route": "/projects/snake_game"
        },
        {
          "name": "GitHub Repo",
          "route": "https://github.com/tychobrouwer/snake-game-electron"
        }
      ]
    }
  ]
}
